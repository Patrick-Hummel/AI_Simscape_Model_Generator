# -*- coding: utf-8 -*-

"""
Abstract system model generated by AI, using abstract components and connections.

Last modification: 01.02.2024
"""

__version__ = "1"
__author__ = "Patrick Hummel"

from typing import List

import networkx as nx
from networkx import Graph

from src.abstract_model.abstract_components import AbstractComponent
from src.abstract_model.abstract_connections import AbstractConnection
from src.tools.custom_errors import AbstractComponentError, AbstractConnectionError


class AbstractSystem:

    def __init__(self):
        self._abstract_components_list = []
        self._abstract_connections_list = []

    @property
    def abstract_components_list(self) -> List[AbstractComponent]:
        return self._abstract_components_list

    @property
    def abstract_connections_list(self) -> List[AbstractConnection]:
        return self._abstract_connections_list

    def create_from_json_data(self, json_data: dict):
        """
        Create an abstract system from json data (dictionary)

        :param json_data: The LLMs abstract system model as json data represented by a dictionary.
        :return: None.

        :raises AbstractComponentError: If there is an error with an abstract component (f.e. wrong name)
        :raises AbstractConnectionError: If there is an error with an abstract connection (f.e. wrong ports)
        """

        implemented_component_types_dict = AbstractComponent.get_implemented_component_types_dict()

        # Automatic error checking
        not_implemented_components_list = []

        for component in json_data.get("components", []):

            comp_unique_name = component['id']
            comp_unique_name_split = comp_unique_name.split("_")
            comp_type = comp_unique_name_split[0]

            if comp_type not in implemented_component_types_dict:
                not_implemented_components_list.append(comp_unique_name)

        if len(not_implemented_components_list) > 0:
            raise AbstractComponentError(message="Component names invalid.", list_wrong_components=not_implemented_components_list)

        new_comp_dict = {}

        # Iterate through components
        for component in json_data.get("components", []):

            comp_unique_name = component['id']
            comp_unique_name_split = comp_unique_name.split("_")
            comp_type = comp_unique_name_split[0]

            # If there is no ID, there may only one component of this type, therefore use ID of 0
            if len(comp_unique_name_split) > 1:
                comp_id = comp_unique_name_split[1]
            else:
                comp_id = 0

            ports_list = []

            for port in component.get("ports", []):
                ports_list.append(port['id'])

            if comp_type in implemented_component_types_dict:
                new_comp = implemented_component_types_dict[comp_type](comp_id, comp_unique_name, ports_list)
                new_comp_dict[comp_unique_name] = new_comp
                self._abstract_components_list.append(new_comp)
            else:
                raise AbstractComponentError(f"Component of type {component['id']} does not exist")

        for connection in json_data.get("connections", []):

            from_comp = None
            from_port_unique_name = connection["from"]

            to_comp = None
            to_port_unique_name = connection["to"]

            # Go through all components to find references ports (from and to component may be the same)
            for comp in new_comp_dict.keys():

                current_component = new_comp_dict[comp]

                if from_port_unique_name in current_component.ports_list:
                    from_comp = current_component

                if to_port_unique_name in current_component.ports_list:
                    to_comp = current_component

                # Stop search once both components have been found
                if isinstance(from_comp, AbstractComponent) and isinstance(to_comp, AbstractComponent):
                    break

            if isinstance(from_comp, AbstractComponent) and isinstance(to_comp, AbstractComponent):

                # TODO ist this always an error or are there cases where this is necessary?
                if from_comp.unique_name == to_comp.unique_name:
                    raise AbstractConnectionError(f"Loop found, there should not be a connection from {connection['from']} to {connection['to']} (itself)")

                self._abstract_connections_list.append(AbstractConnection(from_comp, from_port_unique_name, to_comp, to_port_unique_name))

            else:
                raise AbstractConnectionError(f"Connection {connection['from']} -> {connection['to']} cannot be created")

    def as_networkx_graph(self) -> Graph:

        abstract_system_graph = nx.Graph()

        edges_list = []

        for connection in self.abstract_connections_list:
            edges_list.append((connection.from_component.unique_name, connection.to_component.unique_name))

        abstract_system_graph.add_edges_from(edges_list)

        components_unique_name_list = [component.unique_name for component in self.abstract_components_list]
        included_node_list = list(abstract_system_graph.nodes)

        for node in components_unique_name_list:
            if node not in included_node_list:
                abstract_system_graph.add_node(node)

        return abstract_system_graph
